{"ast":null,"code":"import { MemoryEventSubscription } from \"./Event\";\nexport const QIService = () => {\n  let Qisession = null; // window.QiSession.connect(function (session) {\n  //     session.service()\n  // })\n\n  const subscribeToALMemoryEvent = function (event, eventCallback, subscribeDoneCallback) {\n    var evt = new MemoryEventSubscription(event);\n    onService(\"ALMemory\", ALMemory => {\n      ALMemory.subscriber(event).then(function (sub) {\n        evt.setSubscriber(sub);\n        sub.signal.connect(eventCallback).then(function (id) {\n          evt.setId(id);\n          if (subscribeDoneCallback) subscribeDoneCallback(id);\n        });\n      }, onALMemoryError);\n    }, null);\n    return evt;\n  };\n\n  const onService = (serviceName, callback, errorCallback) => {\n    connect(session => {\n      session.service(serviceName).then(service => {\n        callback(service);\n      }, () => {\n        var reason = \"Failed getting a NaoQi Module: \" + serviceName;\n        console.log(reason);\n\n        if (errorCallback) {\n          errorCallback(reason);\n        }\n      });\n    }, errorCallback);\n  };\n\n  const connect = (connectedCallback, failureCallback) => {\n    if (Qisession) {\n      // We already have a session, don't create a new one\n      connectedCallback(Qisession);\n      return;\n    } else if (pendingConnectionCallbacks.length > 0) {\n      // A connection attempt is in progress, just add this callback to the queue\n      pendingConnectionCallbacks.push(connectedCallback);\n      return;\n    } else {\n      // Add self to the queue, but create a new connection.\n      pendingConnectionCallbacks.push(connectedCallback);\n    }\n\n    function onConnected(ses) {\n      Qisession = ses;\n      var numCallbacks = pendingConnectionCallbacks.length;\n\n      for (var i = 0; i < numCallbacks; i++) {\n        pendingConnectionCallbacks[i](Qisession);\n      }\n    }\n\n    window.QiSession(onConnected, failureCallback);\n  };\n\n  var onALMemoryError = function (errMsg) {\n    console.log(\"ALMemory error: \" + errMsg);\n  };\n\n  var pendingConnectionCallbacks = [];\n  return {\n    subscribeToALMemoryEvent,\n    onService\n  };\n};\n_c = QIService;\nexport const QiRoboService = QIService();\n\nvar _c;\n\n$RefreshReg$(_c, \"QIService\");","map":{"version":3,"names":["MemoryEventSubscription","QIService","Qisession","subscribeToALMemoryEvent","event","eventCallback","subscribeDoneCallback","evt","onService","ALMemory","subscriber","then","sub","setSubscriber","signal","connect","id","setId","onALMemoryError","serviceName","callback","errorCallback","session","service","reason","console","log","connectedCallback","failureCallback","pendingConnectionCallbacks","length","push","onConnected","ses","numCallbacks","i","window","QiSession","errMsg","QiRoboService"],"sources":["C:/Users/Alfia/Desktop/cst/apps/reactjs-hangman/src/services/QIService.js"],"sourcesContent":["import { MemoryEventSubscription } from \"./Event\";\r\nexport const QIService = () => {\r\n  let Qisession = null;\r\n\r\n  // window.QiSession.connect(function (session) {\r\n  //     session.service()\r\n  // })\r\n\r\n  const subscribeToALMemoryEvent = function(event, eventCallback, subscribeDoneCallback) {\r\n    var evt = new MemoryEventSubscription(event);\r\n    onService(\"ALMemory\", (ALMemory) => {\r\n        ALMemory.subscriber(event).then(function (sub) {\r\n            evt.setSubscriber(sub)\r\n            sub.signal.connect(eventCallback).then(function(id) {\r\n                evt.setId(id);\r\n                if (subscribeDoneCallback) subscribeDoneCallback(id)\r\n            });\r\n        },\r\n        onALMemoryError);\r\n    }, null);\r\n    return evt;\r\n}\r\n  const onService = (serviceName, callback, errorCallback) => {\r\n    connect((session) => {\r\n      session.service(serviceName).then(\r\n        (service) => {\r\n          callback(service);\r\n        },\r\n        () => {\r\n          var reason = \"Failed getting a NaoQi Module: \" + serviceName;\r\n          console.log(reason);\r\n          if (errorCallback) {\r\n            errorCallback(reason);\r\n          }\r\n        }\r\n      );\r\n    }, errorCallback);\r\n  };\r\n\r\n  const connect = (connectedCallback, failureCallback) => {\r\n    if (Qisession) {\r\n      // We already have a session, don't create a new one\r\n      connectedCallback(Qisession);\r\n      return;\r\n    } else if (pendingConnectionCallbacks.length > 0) {\r\n      // A connection attempt is in progress, just add this callback to the queue\r\n      pendingConnectionCallbacks.push(connectedCallback);\r\n      return;\r\n    } else {\r\n      // Add self to the queue, but create a new connection.\r\n      pendingConnectionCallbacks.push(connectedCallback);\r\n    }\r\n\r\n    function onConnected(ses) {\r\n      Qisession = ses;\r\n      var numCallbacks = pendingConnectionCallbacks.length;\r\n      for (var i = 0; i < numCallbacks; i++) {\r\n        pendingConnectionCallbacks[i](Qisession);\r\n      }\r\n    }\r\n\r\n    window.QiSession(onConnected, failureCallback);\r\n  };\r\n\r\n  var onALMemoryError = function (errMsg) {\r\n    console.log(\"ALMemory error: \" + errMsg);\r\n  };\r\n\r\n  var pendingConnectionCallbacks = [];\r\n\r\n\r\n  return {\r\n    subscribeToALMemoryEvent,\r\n    onService\r\n  }\r\n};\r\n\r\nexport const QiRoboService = QIService()"],"mappings":"AAAA,SAASA,uBAAT,QAAwC,SAAxC;AACA,OAAO,MAAMC,SAAS,GAAG,MAAM;EAC7B,IAAIC,SAAS,GAAG,IAAhB,CAD6B,CAG7B;EACA;EACA;;EAEA,MAAMC,wBAAwB,GAAG,UAASC,KAAT,EAAgBC,aAAhB,EAA+BC,qBAA/B,EAAsD;IACrF,IAAIC,GAAG,GAAG,IAAIP,uBAAJ,CAA4BI,KAA5B,CAAV;IACAI,SAAS,CAAC,UAAD,EAAcC,QAAD,IAAc;MAChCA,QAAQ,CAACC,UAAT,CAAoBN,KAApB,EAA2BO,IAA3B,CAAgC,UAAUC,GAAV,EAAe;QAC3CL,GAAG,CAACM,aAAJ,CAAkBD,GAAlB;QACAA,GAAG,CAACE,MAAJ,CAAWC,OAAX,CAAmBV,aAAnB,EAAkCM,IAAlC,CAAuC,UAASK,EAAT,EAAa;UAChDT,GAAG,CAACU,KAAJ,CAAUD,EAAV;UACA,IAAIV,qBAAJ,EAA2BA,qBAAqB,CAACU,EAAD,CAArB;QAC9B,CAHD;MAIH,CAND,EAOAE,eAPA;IAQH,CATQ,EASN,IATM,CAAT;IAUA,OAAOX,GAAP;EACH,CAbC;;EAcA,MAAMC,SAAS,GAAG,CAACW,WAAD,EAAcC,QAAd,EAAwBC,aAAxB,KAA0C;IAC1DN,OAAO,CAAEO,OAAD,IAAa;MACnBA,OAAO,CAACC,OAAR,CAAgBJ,WAAhB,EAA6BR,IAA7B,CACGY,OAAD,IAAa;QACXH,QAAQ,CAACG,OAAD,CAAR;MACD,CAHH,EAIE,MAAM;QACJ,IAAIC,MAAM,GAAG,oCAAoCL,WAAjD;QACAM,OAAO,CAACC,GAAR,CAAYF,MAAZ;;QACA,IAAIH,aAAJ,EAAmB;UACjBA,aAAa,CAACG,MAAD,CAAb;QACD;MACF,CAVH;IAYD,CAbM,EAaJH,aAbI,CAAP;EAcD,CAfD;;EAiBA,MAAMN,OAAO,GAAG,CAACY,iBAAD,EAAoBC,eAApB,KAAwC;IACtD,IAAI1B,SAAJ,EAAe;MACb;MACAyB,iBAAiB,CAACzB,SAAD,CAAjB;MACA;IACD,CAJD,MAIO,IAAI2B,0BAA0B,CAACC,MAA3B,GAAoC,CAAxC,EAA2C;MAChD;MACAD,0BAA0B,CAACE,IAA3B,CAAgCJ,iBAAhC;MACA;IACD,CAJM,MAIA;MACL;MACAE,0BAA0B,CAACE,IAA3B,CAAgCJ,iBAAhC;IACD;;IAED,SAASK,WAAT,CAAqBC,GAArB,EAA0B;MACxB/B,SAAS,GAAG+B,GAAZ;MACA,IAAIC,YAAY,GAAGL,0BAA0B,CAACC,MAA9C;;MACA,KAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,YAApB,EAAkCC,CAAC,EAAnC,EAAuC;QACrCN,0BAA0B,CAACM,CAAD,CAA1B,CAA8BjC,SAA9B;MACD;IACF;;IAEDkC,MAAM,CAACC,SAAP,CAAiBL,WAAjB,EAA8BJ,eAA9B;EACD,CAvBD;;EAyBA,IAAIV,eAAe,GAAG,UAAUoB,MAAV,EAAkB;IACtCb,OAAO,CAACC,GAAR,CAAY,qBAAqBY,MAAjC;EACD,CAFD;;EAIA,IAAIT,0BAA0B,GAAG,EAAjC;EAGA,OAAO;IACL1B,wBADK;IAELK;EAFK,CAAP;AAID,CA1EM;KAAMP,S;AA4Eb,OAAO,MAAMsC,aAAa,GAAGtC,SAAS,EAA/B"},"metadata":{},"sourceType":"module"}